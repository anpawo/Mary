//
// EPITECH PROJECT, 2025
// Glados
// File description:
// Mary Standard library - list
//

import std
import math

/*
add macro [x] = !! x
or smth
*/

struct empty {}

struct elem {
    data: any,
    next: empty | elem
}

type list = empty | elem;

operator ++ precedence 5 (list l, list r) -> list {
    if is(l, "empty") then
    {
        return r;
    }
    if is(r, "empty") then
    {
        return l;
    }
    return elem { data = l.data, next = l.next ++ r };
}

operator :| precedence 5 (any d, list l) -> list {
    return elem { data = d, next = l };
}

operator |: precedence 5 (list l, any d) -> list {
    if is(l, "empty") then
    {
        return elem { data = d, next = empty {} };
    }
    else
    {
        return elem { data = l.data, next = l.next |: d };
    }
}

operator !! precedence 10 (list l, int index) -> null | any {
    if index < 0 || is(l, "empty") then
    {
        return NULL;
    }
    if index == 0 then
    {
        return l.data;
    }
    else
    {
        return l.next !! (index - 1);
    }
}

// ranges inclusive
operator .. precedence 10 (int lowerBound, int upperBound) -> list {
    if lowerBound > upperBound then
    {
        return empty {};
    }
    if lowerBound == upperBound then
    {
        return elem { data = upperBound, next = empty {} };
    }
    return elem { data = lowerBound, next = (lowerBound + 1)..upperBound };
}

function map((any) -> any f, list l) -> list {
    if is(l, "empty") then
    {
        return l;
    }
    return elem { data = f(l.data), next = map(f, l.next) };
}

function filter((any) -> bool p, list l) -> list {
    if is(l, "empty") then
    {
        return l;
    }
    if p(l.data) then
    {
        return elem { data = l.data, next = filter(p, l.next) };
    }
    return filter(p, l.next);
}

function foldl((any, any) -> any f, any acc, list l) -> any {
    if is(l, "empty") then
    {
        return acc;
    }
    foldl(f, f(l.data, acc), l.next);
}

function foldr((any, any) -> any f, any acc, list l) -> any {
    if is(l, "empty") then
    {
        return acc;
    }
    return f(foldr(f, acc, l.next), l.data);
}

function sum(list l) -> number {
    return foldl((+), 0, l);
}

function minimum(list l) -> number {
    return foldl((min), l.data, l);
}

function maximum(list l) -> number {
    return foldl((max), l.data, l);
}

function all((any) -> bool f, list l) -> bool {
    if is(l, "empty") then
    {
        return true;
    }
    if f(l.data) then
    {
        return all(f, l.next);
    }
    return false;
}

function anyP((any) -> bool f, list l) -> bool {
    if is(l, "empty") then
    {
        return false;
    }
    if f(l.data) then
    {
        return true;
    }
    return anyP(f, l.next);
}

function in(any x, list l) -> bool {
    if is(l, "empty") then
    {
        return false;
    }
    if x == l.data then
    {
        return true;
    }
    return in(x, l.next);
}

function len(list l) -> int {
    if is(l, "empty") then
    {
        return 0;
    }
    return 1 + len(l.next);
}
